# ЛР10 — Структуры данных: Stack, Queue, Linked List и бенчмарки

# ТЕОРЕТИЧЕСКАЯ ЧАСТЬ (Краткое изложение на основе материала, представленного в документации Python)
## **Стек (Stack) - pilha**
### ***Принцип: LIFO — Last In, First Out.***

Последний вставленный фрагмент данных первым удаляется. Это концепция стека.
* **Структура данных:** Стек.
* **Как это работает:** Представьте стопку книг: вы кладёте одну на другую, и чтобы удалить одну, нужно начать с последней положенной (той, что сверху). Основные операции — это push (вставка) и pop (удаление).
* **Примеры использования:**
    * **Рекурсия:** Компьютер использует «стек вызовов», чтобы запомнить, куда вернуться после выполнения функции.
    * **Функция «Отмена» (Ctrl+Z):** Текстовый редактор удаляет последнее выполненное действие.
    * **Навигация по вкладкам:** Нажав кнопку «Назад» в браузере, вы возвращаетесь на последнюю посещенную страницу.
* **Операции:**
    + push(x) — положить элемент сверху;
    * pop() — снять верхний элемент;
    * peek() — посмотреть верхний, не снимая.
* **Асимптотика (при реализации на массиве / списке):**
    * push — O(1) амортизированно;
    * pop — O(1);
    * peek — O(1);
    * проверка пустоты — O(1).
## **Очередь (Queue) - Fila**
### ***Принцип: FIFO — First In, First Out.***
Первые вставленные данные первыми удаляются. Это концепция очереди.
* **Структура данных:** Очередь.
* **Как это работает:** Представьте себе очередь в банке. Кто первый пришёл, тот и обслуживается первым. Вставки происходят в конце очереди, а удаления — в начале.
* **Примеры использования:**
    * **Планирование процессов:** Операционная система обрабатывает задачи в порядке их запроса.
    * **Буферы печати:** Документы печатаются в порядке их отправки.
    * **Алгоритм поиска в ширину (BFS):** Использует очередь для исследования узлов в графах.
* **Операции:**
    * enqueue(x) — добавить в конец;
    * dequeue() — взять элемент из начала;
    * peek() — посмотреть первый элемент, не удаляя.
* **В Python:**
    * обычный список плохо подходит для реализации очереди:
        * удаление с начала pop(0) — это O(n) (все элементы меняются);
    * Collections.deque дает O(1) операцию по краям:
        * добавить/добавить влево — O(1);
        * поп/поплефт — O(1).
* **Асимптотика (на нормальной очереди):**
    * enqueue — O(1);
    * dequeue — O(1);
    * peek — O(1).
## **Односвязный список (Singly Linked List)**
**Связные списки** — это упорядоченные коллекции объектов. Связные списки отличаются от обычных списков способом хранения элементов в памяти. В то время как обычные списки используют непрерывный блок памяти для хранения ссылок на свои данные, связанные списки хранят ссылки как часть своих собственных элементов.
### ***Ключевые понятия***
Каждый элемент в связанном списке называется **узлом**, и каждый узел имеет два разных поля:
1. **Поле data** содержит значение, которое будет сохранено в узле.
2. **Поле "next"** содержит ссылку на следующий узел в списке. Вот как выглядит типичный узел:

![typical node](../../imgs/lab10/typical%20node.png)

Связанный список — это набор узлов. Первый узел называется начальным **head** и служит отправной точкой для любой итерации по списку. Последний узел должен иметь ссылку **next**, указывающую на конечный **узел (None)**, чтобы определить конец списка. Вот как это выглядит:

![Linked List](../../imgs/lab10/linked%20list.png)

**Основные идеи:**
* элементы не хранятся подряд в памяти, как в массиве;
* каждый элемент знает только «следующего соседа».
**Типичные оценки:**
* prepend (добавить в начало) — O(1);
* append:
    * при наличии tail — O(1),
    * без tail — O(n), т.к. требуется пройти до конца;
* поиск по значению — O(n).